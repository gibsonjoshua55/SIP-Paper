\subsection{Existing Solutions}

As I began working on my solution to the problems encountered above, I did come across some existing solutions.  Here I will briefly describe each existing solution and as I explain my solution, I will compare those aspects to the other libraries.

\subsubsection{Hasura}

Hasura is a complete engine for mapping GraphQL queries to a PostgreSQL relational database. From the definition of the data schema, to managing authorization/authentication, to creating an actual server to respond to the requests, the web application manages all of that on its own \cite{hasurainc.HasuraGraphQLEngine}.  By installing the open-source software, the developer gets a web dashboard where the schema is entered and all aspects of the server are managed.  In my experience setting up this solution, it was by far the fastest way to map GraphQL queries to SQL.  Thanks to the web GUI, little documentation is needed to actually define a schema.  The downside, however, is that with the application being defined in the browser, the extensibility of the application is limited to the features already implemented in the software.

\subsubsection{JoinMonster}

JoinMonster is a JavaScript library that similar to my solution. It allows the developer to define a GraphQL Schema and relate it to SQL tables to automatically create SQL queries that Join related tables \cite{carlJoinMonster}.  This solution, being a JavaScript library, is far more extensible.  You can integrate the function to generate SQL queries wherever needed in the structure of your GraphQL server.  In doing this, though, JoinMonster has defined its own mechanism for generating SQL queries instead of employing existing ORM or Query Builder.  As a result, querying the database elsewhere in the application requires either redefined data models, additional libraries, or manually generated queries.