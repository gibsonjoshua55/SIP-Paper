\subsection{Existing Solutions}

As I began working on my solution to the problems encountered above, I did come across some existing solutions.  Here I will briefly describe each existing solution and as I explain my solution, I will compare those aspects of to the other libraries.

\subsubsection{Hasura}

Hasura is a complete engine for mapping GraphQL queries to a PostgreSQL relational database. From the definition of the data schema, to managing authorization/authentication, to creating an actual server to respond to the requests, the web application manages all of that on its own \cite{hasurainc.HasuraGraphQLEngine}.  By installing the open-source software, the developer gets a web dashboard where the schema is entered and all aspects of the server are managed.  In my experience setting up this solution, it was by far the fastest way to map GraphQL queries to SQL.  Thanks to the web GUI, little documentation is need to actually define a schema.  The downside, however, is that with the application being defined in the browser, the extensibility of the application is limited to the features already implemented in the software.

\subsection{JoinMonster}

JoinMonster is a JavaScript library that similar to my solution, allows the developer to define a GraphQL Schema and relate it to SQL tables to automatically create SQL queries that Join related tables \cite{carlJoinMonster}.  This solution, being a JavaScript library is far more extensible.  You can integrate the function to generate SQL queries wherever needed in the structure of your GraphQL server.  In doing this, though, Join Monster has defined its own mechanism for generating SQL queries instead of employing existing ORM or Query Builder.  For this reason, if anywhere else in the application, if you want to use query the database for custom functionality, either queries must be manually generated, or another data model has to be defined for the library that will query the database.