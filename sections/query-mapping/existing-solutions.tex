\subsection{Existing Solutions}

As I began working on my solution to the problems encountered above, I did come across some existing solutions.  Here I will briefly describe each existing solution and as I explain my solution, I will compare those aspects to the other libraries.

\subsubsection{Hasura}

Hasura is a complete engine for mapping GraphQL queries to a PostgreSQL relational database. The application manges the data schema, manages authorization/authentication, and creates an actual server to respond to the requests. \cite{hasurainc.HasuraGraphQLEngine}.  By installing the open-source software, the developer gets a web dashboard where the schema is entered and all aspects of the server are managed.  In my experience setting up this solution, it was by far the fastest way to map GraphQL queries to SQL.  Thanks to the web GUI, little documentation is needed to actually define a schema.  The downside, however, is that because the application is defined in the browser, the extensibility of the application is limited to the features already implemented in the software.

\subsubsection{JoinMonster}

JoinMonster is a JavaScript library that is similar to my solution. It allows the developer to define a GraphQL Schema and relate it to SQL tables to automatically create SQL queries that join related tables \cite{carlJoinMonster}.  This solution, being a JavaScript library, is far more extensible.  You can integrate the function to generate SQL queries wherever needed in the structure of your GraphQL server.  In doing this, though, JoinMonster has defined its own mechanism for generating SQL queries instead of employing existing solutions such as an Object Relation Mapping (ORM), which creates objects based on database responses, or a query builder, which simplifies writing SQL queries.  As a result, querying the database elsewhere in the application requires either redefined data models, additional libraries, or manually generated queries.