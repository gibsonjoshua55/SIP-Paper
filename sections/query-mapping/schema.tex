\subsection{Schema/Data Model}\label{sec:schema}

The first step to mapping GraphQL queries to SQL queries is to define a shared schema between the allowed objects that can be requested in GraphQL and the tables in the relational database.  If the GraphQL schema and the database schema are defined in the same way, then each table in the database becomes a GraphQL type that a client can request.

The first major design question was how to define these schemas simultaneously.  In the JoinMonster library, the data model is only declared for the GraphQL schema and then the developer defines a map from the GraphQL types to SQL Tables \cite{carlJoinMonster}.  This way, the application can join the two tables together and resolve related data.  On the other hand, in Hasura, the GraphQL schema and the database schema are one and the same.  As you define the table schema that Hasura will use to generate SQL tables, a GraphQL schema is generated alongside it \cite{hasurainc.HasuraGraphQLEngine}.

In my solution, similar to Hasura, the data model for the GraphQL schema and the database schema are declared at once, however, they are declared in code instead of in a web interface.  To do this, I integrate two libraries together: \Verb!type-graphql! for the GraphQL schema and \Verb!sequelize! for the database schema.  Thanks to another package called \Verb!sequelize-typescript!, both of these allow the schema to be defined using TypeScript decorators (see Section \ref{sec:typescript}).  As a result, by decorating a single class that defines the schema for the data, I am given a GraphQL schema that defines what data is available, and a schema that is used to make requests to the database.

The example in Appendix \ref{ex:tl-entity}, based on an example from a \Verb!type-graphql! example project, shows how simple it is to define the schema.  The decorator \Verb!@ObjectType()! establishes the class as a GraphQL object type and the \Verb!@Table()! decorator says which table this object type maps to in the database.  Within the class, each \Verb!@Field()! decorator marks the property as being accessible in the GraphQL schema and each \Verb!@Column()! maps the field to a specific column in the database.  The \Verb!@BelongsTo()! decorator is what defines the relationship between two ObjectTypes/Tables.  This metadata is what is eventually used to join the tables together.