\subsection{Schema/Data Model}

The first step to mapping GraphQL queries to SQL queries is to define a shared schema between the allowed objects that can be requested in GraphQL and the tables in the relational database.  If the GraphQL schema and the database schema are defined in the same way, then each table in database becomes a GraphQL type that a client can request.

The first major design question was how to define these schemas at the same time.  In the JoinMonster library, the data model is only declared for the GraphQL schema and then the developer defines a map from the GraphQL types to SQL Tables \cite{carlJoinMonster}.  This way, the application can join the two tables together and resolve related data.  On the other hand, in Hasura, the GraphQL schema and the database schema are one in the same.  As you define the table schema that Hasura will use to generate SQL tables, a GraphQL schema is generated alongside it \cite{hasurainc.HasuraGraphQLEngine}.

In my solution, similar to Hasura, the data model for the GraphQL schema and the database schema are declared at once, however, they are declared in code instead of in a web interface.  To do this, I am integrating two libraries together: \Verb!type-graphql! for the GraphQL schema and \Verb!sequelize! for the database schema.  Thanks to another package called \Verb!sequelize-typescript!, both of these libraries allow for defining the schema using TypeScript decorators (see Section \ref{sec:typescript}).  As a result, by decorating a single, class that defines the schema for the data, I am given a GraphQL schema that defines that data is available, and a schema that used to make requests to the database.

\begin{figure}
    \begin{verbatim}
@ObjectType()
@Table({
    tableName: 'timestamp_labels',
    underscored: true
})
export class TimestampLabel extends CreatedByEntity<TimestampLabel> {

    @ForeignKey(() => TimestampCollection)
    @Column({
        type: Sequelize.BIGINT,
        field: 'timestamp_collection_id'
    })
    timestampCollectionId: number;

    @Field()
    @Column({
        type: Sequelize.STRING,
        field: 'title',
        allowNull: true
    })
    title: string;

    @Field()
    @Column({
        type: Sequelize.INTEGER,
        field: 'position'
    })
    position: number;

    @Field(() => TimestampCollection)
    @BelongsTo(() => TimestampCollection)
    timestampCollection: TimestampCollection;
}
    \end{verbatim}
    \caption{An example GraphQL/Database Schema}
    \label{fig:example-entity}
\end{figure}

Figure \ref{fig:example-entity} is based on an example from a \Verb!type-graphql! example project and shows how simple it is to define the schema.  The decorator \Verb!@ObjectType()! establishes the class as a GraphQL object type and the \Verb!@Table()! decorator says which table this object type maps to in the database.  Within the class, each \Verb!@Field()! decorator marks the property as being accessible in the GraphQL schema and each \Verb!@Column()! maps the field to a specific column in the database.  The \Verb!@BelongsTo()! decorator is what defines the relationship between two ObjectTypes/Tables.  This metadata is what is eventually used to join the tables together.