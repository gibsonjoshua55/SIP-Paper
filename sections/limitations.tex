\section{Query Mapping Limitations}
The main limitation on this project is that query mapping as it stands is incomplete. As implemented, the algorithm assumes that there is only one GraphQL request being made at a time.  In the GraphQL Specification, and in Nest.js's implementation, multiple GraphQL requests can be sent at once and the server will respond with once with the result of both queries.  If multiple queries are sent, the \verb!ConstructsInclude! function would return the includes for the first query for all requested queries.

Adjusting the \verb!ConstructsInclude! function will not be too difficult of a task.  Instead of just inspecting the top level query, the function will instead analyze each query separately.  The major difficulty is that the function is going to be called once for each request.  In order to analyze the correct query, the resolver were need to have some context about which request should be analyzed.  My guess is that I will be able receive this information in some way from Nest.js.  Somehow Nest.js knows which resolver functions to call, so it must have some metadata somewhere about which query is being request by the client.  Once I determine how to retrieve this information from Nest.js, the adjustment to the \verb!ConstructsInclude! function should be very reasonable.

Additionally, the query mapping does not currently support union types.  These would occur if the server could return multiple different object types on a single connection.  The example in the GraphQL documentation for union types gives the example of a search that could return three different types.  The request will then specify what fields they want for each those types.  The problem with trying to support union types is that they do not fit well with relational databases.  In a relational database, it is known what the type of each related data is.  It can not be multiple possible types, such as with a union type.  The ability to have flexible types like union types is also known as a polymorphic table design.  These tables can be useful, but ultimately present significant challenges to traditional relational database design.  Designing an elegant to solution to supporting union types would certainly be useful, but would be a significant task.  As long as this project continues to focus on mapping GraphQL queries to SQL queries, this problem will probably not be a major focus.

Overall project works as I hoped it would, but it requires the user to limit their use of GraphQL, as well as know where these limitations are.  If this project was open sourced today and other developers began using the framework, it would likely be a frustrating experience discovering what features they could use and what they could not.  To address these issues, much more research into the GraphQL Abstract Syntax Tree and how to parse computer languages in general, will need to be conducted.