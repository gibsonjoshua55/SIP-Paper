\section{Query Mapping Limitations}
The main limitation on this project is that query mapping as it stands is incomplete. As implemented, the algorithm assumes that there is only one GraphQL request being made at a time.  In the GraphQL specification, and in Nest.js's implementation, multiple GraphQL requests can be sent at once and the server will respond once with the result of both queries.  If multiple queries are sent, the \verb!ConstructsInclude! function would return the includes options for the first query for all requested queries.

To adjust the \verb!ConstructIncludes!, instead of just inspecting the top level query, the function will instead analyze each query separately.  The major difficulty is that the caller will need to tell the \verb!ConstructIncludes! function which query should be analyzed. Typically, this would happen in the resolver class when it calls the \verb!ConstructIncludes! function. The first course of action would be to attempt to retrieve this information from Nest.js.  Somehow Nest.js knows which resolver functions to call based on the GraphQL queries it receives, so it must have some metadata stored about which query is being request by the client.  Once it is determined how to retrieve this information from Nest.js, the adjustment to the \verb!ConstructsIncludes! can be completed.

Additionally, the query mapping does not currently support union types.  These would occur if the server could return multiple different object types on a single connection.  The example in the GraphQL documentation for union types is a search that could return three different types.  The GraphQL request for that function would then specify what fields they want for each those types.  The problem with trying to support union types is that they do not fit well with relational databases.  In a relational database, it is known what the type of each related data is.  At the core database level, it is not possible to store a union type.  There is a way to simulate this flexibility which is known as polymorphic table design.  In this situation, you store a reference to the associated data and store another field denoting what type of data is in the referenced table.  This breaks the ability to have those references as foreign keys in the database, which is the main building block of relational databases. These tables can be useful, but ultimately present significant challenges to traditional relational database design.  For this reason, mapping GraphQL union types to a relational database becomes a complicated task.  As long as this project continues to focus on mapping GraphQL queries to SQL queries, this problem will likely not be a major focus.

Overall, the project works as I hoped it would, but it requires the user to limit their use of GraphQL.  Additionally, developers must be aware of these limitations.  If this project were open-sourced today and other developers began using the framework, it would likely be a frustrating experience discovering what features they could use and what they could not.  To address these issues, additional research into the GraphQL Abstract Syntax Tree and how to parse computer languages in general, will need to be conducted and documented.