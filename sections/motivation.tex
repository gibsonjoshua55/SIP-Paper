\section{Motivation}

\subsection{Practice Liszt}
My discoveries related to GraphQL began with a project I called Practice Liszt.  The main goal of the application was to be a rehearsal tool for musicians. As a percussionist, I found it difficult to practice along with video or audio excerpts on applications such as YouTube or Spotify.  As I would try to practice with sometimes 30 or 45 minute long videos, I would have to write down the times of different sections within a piece.  For example, if I wanted to start my practice at the beginning of as second movement of a piece, I would have to write down the time that occurs in the video, scrub to that time, and then start the video with enough time to pick up my instrument/implements and being playing.

My intended solution to the project was to build a web application where I could create timestamps in these lengthy pieces of audio or video and keep a them in an easily accessible list, hence the pun for a title ``Practice Liszt.'' In the Spring of 2018, I did some basic research into the feasibility of this project.  I confirmed that the YouTube API had adequate controls to change the time of YouTube videos, that the interface could be easily created in React.js, a JavaScript UI Framework, and that GraphQL would be an appropriate means of communicating between the front-end (browser) of the application and the back-end (server and database) of the application.

After this initial mock-up, however, I did not work on the project again until the spring of 2019.  At the time I was interviewing for an intern position at the Kalamazoo company Maestro.  For my interview process, I had to implement a project that could show off my skills as a web developer.  Knowing I wanted to tackle this project in the future, I used this as an opportunity to create a complete prototype of the application.  By the end of the week, I had a working prototype that used React, GraphQL, and a non-relational database to store the timestamps called MongoDB.

Thankfully, the software team at Maestro was impressed by my project and I was offered an internship to work there. Going into the summer, I had planned on continuing to work on the project, from a feature standpoint, while I was not working at Maestro.  Ultimately, my goal was to have an application that was not only simple for a musician to use, but also could be used for academic research. On the musician side, they would be able to create timestamps in multiple versions of a piece (think two different recordings, or a video and a piece of audio), they would be able to share those timestamps with others, and they would be able to keep their timestamps private if they wish.  For academics, I hoped that they would be able to look at what pieces have been timestamped and by extension, what recordings are associated with which pieces and what spots in the pieces are commonly timestamped.

To achieve this academic side of the project, I realized in July that that meant redesigning the database and data model for the application.  In order to associate timestamps with actual published pieces of music, I decided to integrate my database with the MusicBrainz database, which is an open source database of music metadata, such as published works, composers, dates, and numerous other bits of data.  This database, however, was structured as a PostgreSQL database.  For this reason, my database went under a complete re-write between July and August to handle data retrieval from a relational SQL database instead of a non-relation database.  In the process of manually writing the resolvers which took GraphQL queries and responded with the appropriate data, I became frustrated with the need to manually define SQL queries that resolved a GraphQL query.  As I learned more at my internship with Maestro, I felt compelled to find a solution that would reduce the manual work involved in mapping a GraphQL query to the data in a relational database.

\subsection{Maestro}
In June 2019, while working on my Practice Liszt project, I started working at Maestro. My main project over the summer was refactoring the back-end code for a learning management system called Loop.  Our goal  for the project was to move all of the existing code for the web server into the Nest.js framework.  In this process though, we used the refactor as an opportunity to remove a lot of duplicated logic throughout the code base.  Logic around data validation, processing HTTP requests, and permissions/authorization were all redesigned within the project to be more standard and less repetitive.

At the end of the processes, however, due to the nature of the technology being used, a lot of logic was still duplicated throughout the entire application.  Since the application has been written to have static REST endpoints, for every endpoint, we have to define exactly what data should be returned and how to fetch that from the database. With over a two hundred endpoints, this creates code that is often doing the same thing, just in slightly different ways.  Moreover, whenever the front end of the application needed different data a back-end developer has to make a change to the code base to manually include or reformat specific fields.

As a developer at Maestro, while I was working on this refactoring project, I was also given the opportunity to participate in bi-weekly ``Developer Days.''  Somewhat inspired by Google's 20\% time, every other Friday, developers were encouraged to use their work days to work on any kind of software projects they were interested in.  The goal of the day was not to contribute productively to current projects, but to allow developers to explore topics and technologies that they were interested in.

Through my summer as an intern, I spent a number of my Developer Days focused on this idea of automated GraphQL/SQL queries. While the project, I approached it from was my Practice Liszt project, which I thought would be the focus of my SIP, the applicability to work projects became more clear the longer I worked on refactoring the Loop web server.  As I continued to share my progress from Developer Days, my coworker's interst in the project continued to grow and discussions began to occur about how we could potentially integrate this into future projects.  As of the time of writing, our hope is that this system could be our standard way of exposing data from a relational database.