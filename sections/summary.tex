\section{Summary}

GraphQL, a querying language developed by Facebook and open sourced in 2015.  The fundamental idea is that the requesting party can request exactly the data they need from the server by specifying the required data that is defined in a graph of related data.  Interestingly, this sounds somewhat similar to a relational database, where individual tables of data are related to one another to create a graph of sorts of connected data; however, GraphQL has typically been utilized in exposing NoSQL/Non-relational databases such as MongoDB.  Facebook themselves created a tool to utilize GraphQL for NoSQL called Dataloader which solves the n+1 problem for fetching related documents.  However, Dataloader requires an individual query to the database for each connected object, which when applied to Relational Databases, nullifies many of the advantages of such a system.

Some solutions due exist for this problem such as Hasura and JoinMonster; however, these projects do not easily allow developers to easily integrate with other projects.  Both require that the database schema be completely redefined, that logic around what kind of data can be requested, and who has access to It all are defined in the same place.  While this is convenient for generating queries, it makes modularizing and reusing code difficult.  For example, a developer could not use a database model defined in JoinMonster to manually query the database in response to a REST API request, or on a background job.

In response to this problem, I have designed a library of functions that work with existing GraphQL and SQL Typescript libraries to generate SQL queries based on a GraphQL request.  In this library, I connect two decorator-based schema definition libraries, TypeGraphQL and Sequelize-Typescript, to create a shared schema that allows for automatic query generation and the existence of two independent schemas that can be used separately from each other.  Additionally, the library comes with a base level service that controls how data is fetch from the database, and a base resolver that uses decorators to process arguments from the GraphQL request and dynamically adjust the SQL query that is generated.
	
