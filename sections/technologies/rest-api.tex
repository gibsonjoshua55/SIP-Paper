\subsection{REST API}
In 2000, Roy Fielding wrote a PhD thesis focusing on the software architecture of web applications \cite{fieldingArchitecturalStylesDesign2000}.  In this dissertation, Fielding defined a style of designing web servers called Representational State Transfer (REST).  Since then, REST APIs have been the de facto standard for organizing services that send data over the internet.  Whether it is requesting individual web pages or bits of data to be used in an application, REST design patterns are often used. 

To this day, the basic constraints laid out in Fielding's dissertation are still used as the tenants of well designed RESTful interfaces.  A quick Google search of REST principles will bring up hundreds of blog posts and tutorials summarizing these guidelines. For more information about REST, the reader is encouraged to do this additional research, however, I will include a brief summary below of the basic REST principles.

\subsubsection{REST Principles}

\begin{itemize}
    \item \textbf{Client-Server:} There should be a division between the software that stores and retrieves data and the software that displays the data.
    \item \textbf{Stateless:} All of the data required to respond to the request should be contained in the request. The server should not store the state of its interaction with the client. That is the client's responsibility.
    \item \textbf{Cache:} The results of a server request should be labeled as cacheable or non-cacheable.  Cacheable requests should not be re-requested for a certain time period to improve network efficiency.
    \item \textbf{Uniform Interface:} All REST services should respond in a uniform way, with each resource having a Unique Resource Identifier (URI).  Through these standard interfaces, web browser can go to nearly any web page without specific configuration.
    \item \textbf{Layered System:} The client is only aware of the top most layer of a REST system, but there may be many layers beneath the public facing layer that process the request.
    \item \textbf{Code-On-Demand:} The client can request code that extends the functionality of the application.  This is the basis of how browsers work.  They request code in the form of HTML, CSS, and JavaScript, which run on the machine and also often continue to request more code.
\end{itemize}

Thankfully, most of these principles are handled without much interference by the modern day developer. Caching, Layered Systems, and Code-On-Demand, are all key aspects implemented by web browsers and operating systems.  What takes most of the work on the developer's part is the organization of data into a Uniform Interface. In a REST API, if I want to request the Course with an id of 1, the URI I use to request that resource might be \Verb"/api/courses/1".  You might notice that this looks very similar to a web URL.  This is because both REST APIs and web page requests use HTTP requests to request data. HTTP requests are split up using different methods such as GET, POST, PUT, etc. Often, when retrieving data an HTTP GET request is used.  An edit to that resource might then come through a PUT or DELETE request.

\subsubsection{REST vs. GraphQL}
Given how often GraphQL is discussed as an alternative to REST APIs, it should be noted that many of REST's principles are typically implemented in a GraphQL API.  GraphQL servers respond to requests from client programs, GraphQL requests are often cached by their clients, such as the Apollo GraphQL client, and the web servers that respond to GraphQL requests are stateless and behind layered systems.  The biggest deviations from REST are in the fact that the organization of a GraphQL API is not through a Uniform Interface. In GraphQL, all allowed queries and mutations are sent through a single \verb!/graphql! endpoint.  Those requests then have a query name or mutation name attached to them that the GraphQL server interprets and then properly responds to the client.  This allows for a much more flexible, but necessarily uniform, interface; however, since all requests are still HTTP requests, the basis of all web communication, clients to send and receive GraphQL requests can be implemented in almost any language and sent from almost any device.