\section{Introduction}

Programming is often a balance of writing original functionality while abstracting away often repeated code.  Instead of copying and pasting complicated code everywhere it is needed, developers seek to extract that code into its own function and reuse it through a project. This balance is a delicate game.  If the developer is left with less abstraction, they may have more control over their implementation. This lack of abstraction makes implementing new features difficult since every bit of functionality has to be re-written for each new context.  On the other hand, too much abstraction leaves the developer with little ability to adapt to their specific situation.

For small agencies that are contracted to create custom software, such as Maestro in Kalamazoo, MI, many common tasks are repeated:  services should have some form of authentication/authorization, keep track of users as they perform actions on a data set, and offer some way to request data from the service, among numerous other tasks.  While organizations over time build expertise in managing these aspects of systems, regardless of the skill of the developer, continually recreating each one of these subsystems takes a significant amount of time.  The question then becomes, what parts of this functionality could be reused across projects and what custom features should stay in individual applications.

This debate ultimately leads to what developers refer to as opinionated vs unopinionated frameworks.  An opinionated framework gives extra tools to reduce the amount of code that has to be written from scratch; however, there are often only a few correct ways to implement these features.  An unopinionated framework, on the other hand, gives the developer the basic tools needed to build their software, but the specific solutions they employ are often left up to the developer using the framework.

When I started working at Maestro as an intern and eventually Apprentice Software Engineer, the team I was a part of did have a standard way to build web servers, but they did not have framework in code to enforce those standards.  Each project was implemented in a very similar way, but features were still duplicated across each application.  For this reason, we have started to plan an opinionated framework that is specific to our team and would abstract away this repeated code.

As these framework conversations were beginning to develop, I also became interested in how to automate the translation of GraphQL queries into SQL queries.  These two languages, which are discussed below, are two common languages used to request data from a remote service.  GraphQL is focused on the communication between web browsers and web servers, whereas SQL is a language for requesting data from relational databases.  This translation functionality would allow web clients to request data from a server in any shape they desired.  Instead of the web server having to define queries for each shape of data needed by the client, the server could just respond dynamically to any data requested.  As I continued to investigate this feature, the applicability to an opinionated framework became clear.

In this paper, I will go into depth on my attempts to create a framework to automate the data fetching functionality of a web server. This framework will make it simple for a developer to define data types to be available in their web server and have those data types immediately available for clients to read, write, and update.  With this baseline functionality, duplicated code related to these operations can be removed from the software and will enable developers to maintain less code and develop more features.  This logic, however, is not specific to any project.  As will be discussed, the idea for this framework began in an independent project, was inspired by a project for Maestro, and has now developed into a project of its own.  The generality of this framework should allow it to be used for any application that needs a web server that exposes data from a database.