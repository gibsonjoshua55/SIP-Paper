\section{Introduction}

Programming is often a balance of writing original functionality while abstracting away often repeated code.  This balance is a delicate game.  If the developer is left with too much control, the lack of abstraction makes implementing new features difficult and every bit of functionality has to be re-written for the new context.  On the other hand, too much abstraction leaves the developer with little ability to adapt to their specific situation.

For small agencies that are contracted to create custom software, such as Maestro in Kalamazoo, MI, many common tasks are repeated:  the service needs to have some form of authentication/authorization, it should keep track of users as they perform actions on a data set, it should offer some way to request data from the service, and numerous other tasks.  While organizations over time build expertise in managing these aspects of systems, regardless of the skill of the developer, having to recreate each one of these subsystems will take a significant amount of time.  The question then becomes, what parts of this functionality could be reused across projects and what custom features should stay in individual applications.

This debate is ultimately what leads to what people refer to as opinionated vs unopinionated frameworks.  An opinionated framework gives extra tools to reduce the amount of code that has to be written from scratch; however, this is often on a few correct ways to implement these features.  An unopinionated framework, on the other hand, gives the developer the basic tools need to build their software, but the specific solutions they employ are often left up to the developer using the framework.

When I started working at Maestro as an Intern and eventually Apprentice Software Engineer, we did have opinions on how to build web servers, but we did not have any kind of framework enforce that.  Each project was implemented in a very similar way, but features were duplicated across each application.  For this reason, planning has begun to create a framework, specific to our team, that would abstract away this repeated code.

As these framework conversations were beginning to develop, however, I also became interested in how to automate the translation of GraphQL queries into SQL queries.  This functionality would allow web clients to request data from a server in any shape they requested.  Instead of the backend having to define queries for each shape of data needed by the client, the server could just respond dynamically to any data requested.  As I continued to investigate this feature, the applicability to an opinionated framework became clear.

In this paper, I will be going into depth on my attempts to automate the data fetching functionality of a web server as well as some of the customizability and extensions I have worked on to make the feature reusable to across projects.  The goal of this, however, is ultimately to integrate this into a complete framework that will enable Maestro to standardize their web server architecture and shift our development time from re-implementing features to making improvements to the core framework used across all future projects. 