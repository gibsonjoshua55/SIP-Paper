\section{Future Work}

The majority of future work is centered around customizing the resolver.  When developing an application, it is common to need the ability to dynamically filter and change the data set being returned by a query.  For example you might want to change the order that data is returned, only want to view a page's worth of data, or only want to query objects where a certain condition is true or false.  Each one of these actions would be prompted by different parameters on the query.  In this section, I will propose how those features might look for the developer once they are fully implemented.

\subsection{Pagination}

A common feature of large applications is viewing paginated subsets of data.  For example, in the Practice Liszt app, there might be thousands of public timestamp collections, but the user can only view ten at a time on the displaying web page.  The GraphQL server then needs a way to deliver these thousands of records in pages of ten records at a time to the client.  I believe this feature will be possible to integrate into my framework, but will require effort in both research and implementation.  At the resolver level, the number of results per page and the page to retrieve will have to become arguments for each paginated query. These options will then be merged into the service's options so only that subset of data is retrieved from the database.  Additionally, a default sort order will have to be chosen before paginating the data.  If no default sort order is determined, the database doesn't know what order the ``pages'' are in.  If the order is left random, ``Page 2'' will be different every time.  By having a default sort order, as the client requests subsequent pages, only new data will be returned on each request.

\subsection{Sorting}

In addition to a default sort order, it will also be necessary to allow the client to modify the sort order of the results.  In a web application, it is common to change sorting from alphabetical by name, to reverse alphabetical, or sometimes a different property such as creation time.  The goal would be on the top level of the query, the client would be able to select an argument specified from a list of pre-defined sortable properties.

These sortable properties could be defined in two places.  Option one would be in the resolver.  This could become another option of the base resolver where the developer simply provides a list of sortable properties.  The resolver then provides those as possible arguments to the client.  A potentially more elegant, but more complicated, solution would be to have a decorator on the entity that marks those database fields sortable.  The resolver would then look at the entity and identify its sortable fields and use those for the list of acceptable sorting properties.

\subsection{Filtering}

The most complicated bit of key functionality left to implement is filtering data based on arguments passed to the query.  An example of this would be searching for a certain Timestamp Label.  On the query, you might provide it a string to match and only Timestamp Labels that match that key will be included in the data set.

The difficulty in this use case is determining where to define the filtering behavior and at what step in the process to actually inject the filter into the query.  Ideally, the definition of the filter will be on the resolver. At this level, the developer will declare what arguments are available to the the client and will also define what behavior the filter will have.  Applying the filter to the query will have to occur in the \verb!ConstructIncludes! function, however.  Since multiple filters could be applied at multiple levels of the query, it is not enough to just process the top level arguments.  The \verb!ConstructIncludes! function will need to parse the parameters at each level and determine what filters should be applied.  It will then inspect the metadata applied to the resolver to retrieve the defined behavior.  That behavior will be executed and then inserted into the query.  The parsing problem in this situation is similar to sorting, but since the behavior is far more dynamic than sorting, the implementation within that function will be much more complicated.