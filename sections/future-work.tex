\section{Future Work}

The majority of future work is centered around the customizing the resolver.  When developing an application, it is common to need the ability to dynamically filter and change the data set being returned by a query.  For example you might want to change the order that data is returned, only want to view a page's worth of data, or you may only want to query objects where a certain condition is true or false.  Each one of these actions would be prompted by different parameters on the query.  In this section, I will propose how those features might look for the developer once they are fully implemented.

\subsection{Pagination}

A common feature of large applications is viewing paginated subsets of data.  For example, in the Practice Liszt app, there might be thousands of public timestamp collections, but the user can only view ten at a time.  The GraphQL server, then needs a way to deliver these thousands of records in pages to the server.  I believe this feature will be possible to integrate into my framework, but it will take some work.  At the resolver level, the number of results and the page to retrieve will have to become arguments for each paginated query. These options will then be merged into the service's options to only query the database for that subset of data.  Additionally, a default sort order will have to be chosen before paginating the data.  If no default sort order is determined, the database doesn't know what order the "pages" are in.  If the order is left random, "Page 2" will be different every time.  By having a default sort order, as the client requests subsequent pages, only new data will be returned on each request.

\subsection{Sorting}

In addition to a default sort order, it will also be necessary to allow the client to modify the sort order of the results.  In a web application, it is common to change sorting from alphabetical by name, to reverse alphabetical, or sometimes a different property such as creation time.  The goal would be on the top level of the query, the client would be able to provide an argument that specifies from a list of pre-defined sortable properties which one will be used.

Where these sortable properties could be defined could occur in two places.  Option one would be in the resolver.  This could become another option of the base resolver where the developer simply provides a list of sortable properties.  The resolver then provides those as possible arguments to the client.  What I think would be a more elegant, but more complicated solution, would be to have a decorator on the entity that marks those database fields sortable.  The resolver will then look at the entity to see which fields it has as sortable and will then use those for the list of acceptable sorting properties.

\subsection{Filtering}

The most complicated bit of key functionality left to implement is filtering data based on arguments passed to the query.  An example of this would be searching for a certain Timestamp Label.  On the query, you might give it a string to match and only Timestamp Labels that match that key will be included in the data set.

The difficulty in this use case is determining where to define the filtering behavior and at what step in the process to actually inject the filter into the query.  Ideally the definition of the filter will be on the resolver. At this level, the developer will declare what arguments the client has available to them and will also define what behavior the filter will have.  Applying the filter to the query will have to occur in the \verb!ConstructIncludes! function, however.  Since multiple filters could be applied at multiple levels of the query, it is not enough to just process the top level arguments.  The construct includes function will need to at each level parse the parameters and determine what filters should be applied.  It will then inspect the metadata applied to the resolver to retrieve the defined behavior.  That behavior will be executed and then inserted into the query.  The parsing problem in this situation is similar to sorting, but since the behavior is far more dynamic than sorting, the implementation within that function will be much more complicated.