\section{Conclusion}

Developing a whole new framework for developing web application back-ends is ultimately a huge task.  Open source communities of thousands of people support some of the largest frameworks that have taken years to develop. Throughout the paper I have used this idea of a framework to describe the three key reusable entities I have developed, \verb!BaseEntity!, \verb!BaseService!, and \verb!BaseResolver!.  What I am implying is that these classes provide the developer more with an opinionated way to structure their back-end.  Additionally, by using this base structure, some basic functionality surrounding reading and writing the data will also be available by default.

In contrast to most frameworks, however, this project relies heavily on on other projects, notably Nest.js, Type-GraphQL, Sequelize, and Sequelize Typescript.  Rather than trying to re-write these projects to work exactly as desired, the project augments each project in specific ways to work work together and speed up development time while reducing repeated code.

Looking back to the summer when this project developed, it was my frustration with the amount of repeated code that I found across my personal and work projects.  This project doesn't necessarily change the structure of these applications, but instead enforces common base implementation across the whole application. In this way improvements made the base classes reach across the whole application.

As we continue to refine are development process at Maestro, this is going to be our guiding principle moving forward.  Even across projects, we want to move to have one opinionated and pre-implemented way to do as much of our projects as possible.  This way, those apps that don't need custom functionality will no longer has to re-implement the same features over and over again.  This project simply focuses on data mutation and data retrieval using SQL and GraphQL, but so many other features could implemented in an opinionated and reusable way.  A code library with authentication, data retrieval, error handling, and many other features really might be a complete framework.  Nest.js offers all of this, but in as reusable and customizable as possible.  This framework would be a level of abstraction above it.