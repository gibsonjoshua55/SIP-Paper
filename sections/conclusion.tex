\section{Conclusion}

Designing a new framework for developing web application back-ends is no small task.  Open source communities of thousands of people support some of the largest frameworks that have taken years to develop. Throughout the paper I have used this idea of a framework to describe the three key reusable entities I have developed, \verb!BaseEntity!, \verb!BaseService!, and \verb!BaseResolver!.  What these classes should provide to the developer is a clear and opinionated way to structure their GraphQL servers.  Additionally, by using this base structure, some basic functionality surrounding reading and writing the data will also be available by default.

In contrast to most frameworks, however, this project relies heavily on on other projects, notably Nest.js, Type-GraphQL, Sequelize, and Sequelize Typescript.  Rather than trying to re-write these projects to work exactly as desired, the project augments each project in specific ways to work together and speed up development time while reducing repeated code.

Looking back to the summer when this project developed, it my frustration with the amount of repeated code that I found across my personal and work projects that led me to devote my time to investigating automated data fetching.  By providing a set a of base classes to use throughout an application, this framework has the potential to reduce duplicated code related to creating, reading, updating, and deleting data from a database.  It is also flexible enough to leave room for some custom implementation.  This is necessary since each app will be developed in its own context, but it also leaves room for misuse.  A developer could ignore the patterns provided by the three base classes and continue to duplicate logic throughout the application.  As is always the case with programming, clean and maintainable code will only come through a combination of design and discipline in implementation.

As we continue to refine our development process at Maestro, creating more re-usable patterns will be our goal moving forward.  Even across projects, we want to move to have one opinionated and pre-implemented way to do as much of our projects as possible.  This way, those apps that do not require custom functionality will no longer have to re-implement the same features repeatedly.  This project simply focuses on data mutation and data retrieval using SQL and GraphQL, but additional features could implemented in an opinionated and reusable way.  A code library with basic implementations for features including authentication, data retrieval, and error handling, would enable us to develop applications for a clients at a speed and consistency we have not been able to achieve previously.