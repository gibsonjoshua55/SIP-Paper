\subsection{Base Resolver}
The resolver is what exposes all of the functionality of the services to clients through GraphQL queries and mutations. The entities and services have created all of the functionality to interact with the database, but they do not provide any public APIs for clients to take advantage of this functionality.  The resolver is what creates public functions that clients call to interact with data.  These function calls are in the GraphQL language.  The server then processes these requests and forwards them to the resolver, which is in charge of fetching or mutating the requested data.  The \verb!BaseResolver! is a class that automatically provides CRUD operations for a given data type when supplied a service class that extends the \verb!BaseService!. The idea for the \verb!BaseResolver! comes from the TypeGraphQL documentation \cite{lytekTypegraphql2019}, where they have an example to create a \verb!BaseResolver!.  In my version of this example, I have integrated it with the \verb!BaseService! and also allowed the developer to turn on and off the functions defined by the \verb!BaseResolver!. By default, a resolver extending the \verb!BaseResolver! will receive the following queries from the \verb!BaseResolver! class: \verb!getOne! and \verb!getAll!.  It will also have the following GraphQL mutations: \verb!create!, \verb!update! and \verb!delete!.  When implementing a resolver that extends a \verb!BaseResolver!, all the developer must provide to the resolver is a service that extends the \verb!BaseService! that will fetch and mutate the data managed by the resolver.

\subsubsection{Connecting the Dots}

The resolver ultimately connects all aspects of the application together.  When a request is received, Nest.js sends the request to the associated resolving function for that request, which will either be defined by the \verb!BaseResolver! for simple CRUD functionality, or will be defined in an implementing resolver for custom functionality.  For all of the requests built into the \verb!BaseResolver!, the function then retrieves the requested data by calling the \verb!ConstructIncludes! function and passing that query into the service which will actually fetch the data from the database.  That resolver then returns that data to the GraphQL server which forwards the result back to the client.

\subsubsection{Custom Functionality}

When the developer extends the \verb!BaseResolver! to create a concrete resolver for a specific type, it is here that they have specific control over what queries and mutations are available on the server.  In this implementing class, the developer can turn on and off creating, updating, and deleting of the object, they can set guards to limit access to certain functions, they can they can implement custom queries, and they can override any functionality defined in the \verb!BaseResolver!.