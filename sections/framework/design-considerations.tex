\subsection{Dependency Injection}
The framework is heavily influenced by dependency injection, the pattern coined by Martin Fowler and popularized by the Java Spring framework \cite{fowlerInversionControlContainers2004}, and the Adapter pattern outlined in the book \textit{Design Patterns: Elements of Reusable Object Oriented Software} by Gamma, et. al \cite{gammaDesignPatternsElements1995}.  These two patterns when combined allow independent implementations of creating, reading, updating, and deleting data to be developed for each data type, while a standard interface allows for basic code to be reused across each data type.

\subsubsection{Dependency Injection}
The Dependency Injection pattern is a way of providing dependencies to an instance of a class, rather than them being defined in the class itself \cite{fowlerInversionControlContainers2004}. A dependency in this situation can be many things.  It might be an external code library, a object created within the application, or even configuration options for the application.  Instead of hard-coding these in to the software, dependency injection encourages flexibility in swapping out dependencies where needed. What this allows is for behavior to change for specific actions implemented by the dependency, while the implementation of the parent class does not have to change.  In my framework, the clearest use of dependency injection occurs between the \verb!BaseResolver! and the \verb!BaseService!.  The resolver class may define any number of queries or mutations on an object to either create an object, read an object from a data source, update an object, or delete an object (these operations are commonly abbreviated as CRUD).  The implementation for each of these actions on the database, however, may be different for each object type.  These implementations live in the subclasses of the \verb!BaseService!.  For a specific object type, a service class will be defined that contains the logic to perform all CRUD operations and an instance of this class is then injected into the resolver for that type.  Thus the resolver doesn't depend on a specific implementation for each type of object; it receives an instance of the service that knows how to modify the object in the database and simply forwards the requests to the service instance.

\subsubsection{Adapter Pattern}
The \verb!BaseService!, which is what is injected into the \verb!BaseResolver!, is also an example of the Adapter Pattern.  This pattern from Gamma's \textit{Design Patterns} is when a class wraps another existing class to provide additional functionality.  As will be discussed in more detail below, the \verb!BaseService! and its extending classes, are what communicate with the database.  Sequelize, the tool used to create SQL queries, already provides this functionality; however, at a framework level, we want to add another layer on top of Sequelize.  The \verb!BaseService! provides many of the same functions that Sequelize does, but also adds functionality such as error handling and combining queries to remove duplicated options when those Sequelize functions are called.  To do this, the \verb!BaseService! has its own functions such as \verb!create!, \verb!update!, and \verb!findOne! that call those same functions in Sequelize directly, while adding logic around them.  It is this service that is then used throughout the rest of the application, not the Sequelize code directly.  In this way, the resolver can take advantage of new functionality that allows it to take use the \verb!ConstructIncludes! to resolve GraphQL queries automatically.
