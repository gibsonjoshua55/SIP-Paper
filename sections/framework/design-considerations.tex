\subsection{Design Considerations}
The framework is heavily influenced by two design patterns: dependency injection, the pattern coined by Martin Fowler and popularized by the Java Spring framework \cite{fowlerInversionControlContainers2004}, the Bridge pattern outlined in the book \textit{Design Patterns: Elements of Reusable Object Oriented Software} by Gamma, et. al \cite{gammaDesignPatternsElements1995}.  These two patterns when combined allow independent implementations of creating, reading, updating, and deleting data to be implemented for each data type, while a standard interface allows for basic code to be reused across each data type.

\subsubsection{Dependency Injection}
Following the Dependency Injection Pattern is a way of providing dependencies to an instance of the class, rather than them being defined in the class itself \cite{fowlerInversionControlContainers2004}. What this allows is for behavior to change of specific actions implemented by the dependency, while the parent class does not have to change its implementation at all.  In my framework, the clearest use of dependency injection occurs between the \verb!BaseResolver! and the \verb!BaseService!.  A resolver, in a GraphQL Server, is what defines the functions that are available for a client to call.  For example, it may define a query or mutation to create an object, read an object, update an object, or delete an object (these operations are commonly abbreviated as CRUD).  The implementation for each of these actions on the database, however, may be different for each object type.  These implementations live in the subclasses of the \verb!BaseService!.  For a specific object type, a service class will be defined that contains the logic to perform all CRUD operations and an instance of this class is then injected into the resolver for that type.  Thus the resolver doesn't depend on a specific implementation for each type of object; it receives an instance of the service that knows how to modify the object in the database and simply forwards requests todo so to the service instance.

\subsubsection{Bridge Pattern}
Another perspective on the relationship between the \verb!BaseResolver! and \verb!BaseService! can be seen through the lense of the Bridge pattern.  This pattern from Gamma's \textit{Design Patterns}, similar to Dependency Injection aims to separate the specific implementation of abstraction from the contract it provides to those that call it. In this framework, the \verb!BaseResolver! requires that the \verb!BaseService! provides a certain functionality to modify the database.  For each object type, many of the CRUD operations always exist.  The logic to expose these functions and interact with the database live in the \verb!BaseResolver! and \verb!BaseService! classes.  For each object type, however, there must be a concrete resolver that depends on a concrete service. For example, to modify a \verb!TimestampLabel!, there must be a \verb!TimestampLabelResolver! and a \verb!TimestampLabelService!.  By having the two abstract \verb!BaseResolver! and \verb!BaseService! classes, a certain contract is established that for all subtypes of the two classes. The functionality will always exist to create, read, update, and delete data.  In this sense, the base classes are a bridge between concrete implementations. On the other hand, behavior can still be extended in the concrete implementations without duplicating logic provided by the base classes.