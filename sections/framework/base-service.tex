\subsection{Base Service}
With a standard structure for the data model of each type of data being stored, we can also create a standard set of functions related to creating, reading, updating, or deleting these records.  Once the data model has been established, Sequelize, library used to define the data model, provides a set of functions that directly interact with the database such as \verb!findOne!, \verb!findAll!, \verb!create!, etc.  The \verb!BaseService! wraps these functions to provide additional functionality, as well as enforce certain opinions on how to interact with the data.

\subsubsection{Merge Options}
When making queries to the database with Sequelize, the client is allowed to pass in options to modify the behavior of the query.  For example the options shown in Figure \ref{fig:merge-options} are all examples that would either include data of related tables in the request (through an \verb!include! option) or will limit the data that is returned (through \verb!where! options).  Throughout the \verb!BaseService! class, it will be useful to merge together two different sets of options.  For example, the application may allow the user to search for a timestamp label by its name; however, the user should only have access to labels that they created.  To achieve this, on each call to the database, we can merge in the option \verb!{ where: {createdById: user.id}}! so all requests have that constraint.  Because options are a mix of objects, such as \verb!where! options, and arrays, such as the \verb!include!, the logic to merge these options becomes somewhat complicated.  The solution I came to, however, is to do a deep merge on object values and to iterate through \verb!include! options and either add distinct model to the array, or deep merge matching models.  A deep merge is where the keys and values at each level of an object are combined. On each level, if both objects have the same key, their values are merged as well.  On leafs of the tree, meaning individual values instead of nested objects, one object's value is chosen to have the overriding value, and its value is used in the final result.

For certain parts of the query options, however, this default behavior doesn't work.  For \verb!include! values, for example, the overriding array at the top level would always be the one used, since it wouldn't know how to merge the arrays. Arrays are seen as ``values'', so they wouldn't be merged, but simply overridden.  For the key \verb!includes!, a custom function is given that looks through the two arrays to be merged, and it matches up the objects in the array by their model type.  If there are  two objects have the same model, the same deep merge algorithm is called on those two objects.  Otherwise each included object is added to an array that contains all of the requested models between the two options.

On \verb!where! options, the two \verb!where! clauses are simply wrapped in an \verb!AND! operator.  This allows both constraints to be applied, but no merge has to be computed.

Figure \ref{fig:merge-options} gives an example of what the outcome of this function would be for two example options.

\begin{figure}
    \begin{Verbatim}[fontsize=\footnotesize]
const initialOptions = {
    include: [{
        model: RelatedModel
    }]
    where: {
        createdById: 10
    }
};

const optionsToBeMerged = {
    include: [{
        model: RelatedModel,
        include: [{
            model: ASecondModel
        }],
        where: {
            createdById: 10
        }
    }],
    where: {
        name: 'A Value'
    }
};

const optionsAfterMerge = {
    include: [{
        model: RelatedModel,
        include: [{
            model: ASecondModel
        }],
        where: {
            createdById: 10
        }
    }],
    where: {
        [Op.and]: 
        [
            {
                createdById: 10
            },
            {
                name: 'A Value'
            }
        ]
    }
}
    \end{Verbatim}
    \caption{Example Sequelize Options}
    \label{fig:merge-options}
\end{figure}

\subsubsection{Base Find Options}
With the ability to merge query options, the \verb!BaseService! provides a mechanism of not only overriding the standard behavior of requests on each method call, but it also provides the option to base level constraints on each query.  When extending the \verb!BaseService! class, the subclass can override a function called \verb!getBaseFindOptions!.  This function is called for every fetch to request data from the database and the options it returns are merged into options provided by caller.  A common use case for this would be to use this function to ensure that the user can only access records they created.  Looking at the example service in Appendix \ref{ex:tl-service}, we can see how crucial this ability to limit access is.  For Timestamp Labels, they should only be viewable by the user that created that label, or by any user if its collection is marked as public.  By defining a \verb!getBaseFindOptions! method on an implementing service, that logic is applied to all access operations on this object type.  

This is one of the largest benefits of this framework versus Hasura or JoinMonster.  Since functionality is kept in extendable classes, this kind of behavior can be modified for each type defined in the application. Additionally, because the data model defined in the entity is defined for a fully functional ORM, the developer can use that same data model to modify the functionality of their service. No re-definition has to occur.